#+LATEX_CLASS:llncs
#+LATEX_CLASS_OPTIONS:[runningheads,a4paper]
#+LATEX_HEADER:
#+LATEX_HEADER_EXTRA:
#+DESCRIPTION:
#+KEYWORDS:
#+SUBTITLE:
#+DATE: \today
#+OPTIONS: toc:nil
#+TITLE: Modeling action games as hierarchical hybrid automata
#+AUTHOR: Author One, Author Two
#+EMAIL:
#+LATEX_HEADER_EXTRA: \author{Firstname Lastname \and Firstname Lastname}
#+LATEX_HEADER_EXTRA: \institute{Institute}
#+BIBLIOGRAPHY: padl splncs03
#+PROPERTY: header-args :eval t :cache yes

#+begin_src emacs-lisp :results silent :exports none
(add-to-list 'org-latex-classes
             '("llncs"
               "\\documentclass{llncs}
\\usepackage[AUTO]{inputenc}
                 [NO-DEFAULT-PACKAGES]
                 [EXTRA]
%Even though `american`, `english` and `USenglish` are synonyms for babel package (according to https://tex.stackexchange.com/questions/12775/babel-english-american-usenglish), the llncs document class is prepared to avoid the overriding of certain names (such as \"Abstract.\" -> \"Abstract\" or \"Fig.\" -> \"Figure\") when using `english`, but not when using the other 2.
\\usepackage[english]{babel}

%better font, similar to the default springer font
%cfr-lm is preferred over lmodern. Reasoning at http://tex.stackexchange.com/a/247543/9075
\\usepackage[%
rm={oldstyle=false,proportional=true},%
sf={oldstyle=false,proportional=true},%
tt={oldstyle=false,proportional=true,variable=true},%
qt=false%
]{cfr-lm}
%
%if more space is needed, exchange cfr-lm by mathptmx
%\\usepackage{mathptmx}

\\usepackage{graphicx}

%extended enumerate, such as \\begin{compactenum}
\\usepackage{paralist}

%put figures inside a text
%\\usepackage{picins}
%use
%\\piccaptioninside
%\\piccaption{...}
%\\parpic[r]{\\includegraphics ...}
%Text...

%Sorts the citations in the brackets
%It also allows \\cite{refa, refb}. Otherwise, the document does not compile.
%  Error message: \"White space in argument\"
\\usepackage{cite}

\\usepackage[T1]{fontenc}

%for demonstration purposes only
\\usepackage[math]{blindtext}

%for easy quotations: \\enquote{text}
\\usepackage{csquotes}

%enable margin kerning
\\usepackage{microtype}

%tweak \\url{...}
\\usepackage{url}
\\urlstyle{same}
%improve wrapping of URLs - hint by http://tex.stackexchange.com/a/10419/9075
\\makeatletter
\\g@addto@macro{\\UrlBreaks}{\\UrlOrds}
\\makeatother
%nicer // - solution by http://tex.stackexchange.com/a/98470/9075
%DO NOT ACTIVATE -> prevents line breaks
%\\makeatletter
%\\def\\Url@twoslashes{\\mathchar`\\/\\@ifnextchar/{\\kern-.2em}{}}
%\\g@addto@macro\\UrlSpecials{\\do\\/{\\Url@twoslashes}}
%\\makeatother

%diagonal lines in a table - http://tex.stackexchange.com/questions/17745/diagonal-lines-in-table-cell
%slashbox is not available in texlive (due to licensing) and also gives bad results. This, we use diagbox
%\\usepackage{diagbox}

%required for pdfcomment later
\\usepackage{xcolor}

% new packages BEFORE hyperref
% See also http://tex.stackexchange.com/questions/1863/which-packages-should-be-loaded-after-hyperref-instead-of-before

%enable hyperref without colors and without bookmarks
\\usepackage[
%pdfauthor={},
%pdfsubject={},
%pdftitle={},
%pdfkeywords={},
bookmarks=false,
breaklinks=true,
colorlinks=true,
linkcolor=black,
citecolor=black,
urlcolor=black,
%pdfstartpage=19,
pdfpagelayout=SinglePage,
pdfstartview=Fit
]{hyperref}
%enables correct jumping to figures when referencing
\\usepackage[all]{hypcap}

%enable nice comments
\\usepackage{pdfcomment}
\\newcommand{\\commentontext}[2]{\\colorbox{yellow!60}{#1}\\pdfcomment[color={0.234 0.867 0.211},hoffset=-6pt,voffset=10pt,opacity=0.5]{#2}}
\\newcommand{\\commentatside}[1]{\\pdfcomment[color={0.045 0.278 0.643},icon=Note]{#1}}

%compatibality with TODO package
\\newcommand{\\todo}[1]{\\commentatside{#1}}

%enable \\cref{...} and \\Cref{...} instead of \\ref: Type of reference included in the link
\\usepackage[capitalise,nameinlink]{cleveref}
%Nice formats for \\cref
\\crefname{section}{Sect.}{Sect.}
\\Crefname{section}{Section}{Sections}

\\usepackage{xspace}
%\\newcommand{\\eg}{e.\\,g.\\xspace}
%\\newcommand{\\ie}{i.\\,e.\\xspace}
\\newcommand{\\eg}{e.\\,g.,\\ }
\\newcommand{\\ie}{i.\\,e.,\\ }

%introduce \\powerset - hint by http://matheplanet.com/matheplanet/nuke/html/viewtopic.php?topic=136492&post_id=997377
\\DeclareFontFamily{U}{MnSymbolC}{}
\\DeclareSymbolFont{MnSyC}{U}{MnSymbolC}{m}{n}
\\DeclareFontShape{U}{MnSymbolC}{m}{n}{
    <-6>  MnSymbolC5
   <6-7>  MnSymbolC6
   <7-8>  MnSymbolC7
   <8-9>  MnSymbolC8
   <9-10> MnSymbolC9
  <10-12> MnSymbolC10
  <12->   MnSymbolC12%
}{}
\\DeclareMathSymbol{\\powerset}{\\mathord}{MnSyC}{180}

% correct bad hyphenation here
\\hyphenation{op-tical net-works semi-conduc-tor}

%Works on MiKTeX only
%hint by http://goemonx.blogspot.de/2012/01/pdflatex-ligaturen-und-copynpaste.html
%also http://tex.stackexchange.com/questions/4397/make-ligatures-in-linux-libertine-copyable-and-searchable
%This allows a copy'n'paste of the text from the paper
\\input glyphtounicode.tex
\\pdfgentounicode=1

%If Title is too long, use \\titlerunning
%\\titlerunning{Short Title}"
               ("\\section{%s}" . "\\section*{%s}")
               ("\\subsection{%s}" . "\\subsection*{%s}")
               ("\\subsubsection{%s}" . "\\subsubsection*{%s}")
               ("\\paragraph{%s}" . "\\paragraph*{%s}")
               ("\\subparagraph{%s}" . "\\subparagraph*{%s}")
))

(setcar (nthcdr 2 org-emphasis-regexp-components) " \t\n,:")
(custom-set-variables `(org-emphasis-alist ',org-emphasis-alist))
#+end_src

* Front matter             :ignore:
\begin{abstract}
While action video games share common ancestry with control theory and hybrid systems, declarative notations for games have only seen limited use.  We propose a modeling language that can be given semantics directly or via translation to existing game-making tools.  Design support tools could then be written for this portable format and reused.

Game designers often describe their work in terms of state machines or control envelopes, so we ground our modeling language in hybrid automata, specifically hierarchical hybrid automata.  We select and adapt features and syntax from the hybrid systems literature which are appropriate to the domain of games and hopefully admit tractable, compositional analysis and convenient modeling.
\end{abstract}

\keywords{hybrid automata, action games, domain-specific languages}
* Introduction
In this paper, we consider a particular loosely-defined set of video games commonly referred to as /action games/.
These games center simulations of continuous space and time, collisions between objects, and objects with small sets of discrete variables whose behaviors change under different circumstances (generally indicated by changes in visual appearance).

This category of action games is very expressive, capturing a large number of examples.
Accordingly, many popular game-making tools focus on them: /GameMaker/, /Unity 3D/, /Unreal/, and other systems offer user interfaces and programming APIs supporting collision checking, simple physics, and in some cases state machines.
At the same time, none of these offers significant support for model checking (or even automated testing), visualization of possible system states, parameter synthesis, or other features that the available domain knowledge would seem to enable.
These tools could be of great use to game makers, reducing the need for expensive manual testing.

In our work, we follow after the game description language /cum/ game engine /cum/ model checker BIPED cite:smith2010ludocore: to transform specification into both human-playable games and machine-analyzable systems.
BIPED is specialized for games with discrete state spaces and fairly coarse discrete time; what would a BIPED-like system for continuous-time games with hundreds of real-valued variables look like?
We answer this question by combining folk approaches of action game makers---state machines, object pooling, broad-vs-narrow phase collision detection (which calls separation logic to mind), game physics simulation, and so on---with formal approaches from the hybrid systems literature.
Our language and system are called HyPED (Hybrid BIPED).
The following sections position HyPED in relation to existing formalisms for hybrid automata and action game specification, provide its semantics and examples, and point to future applications and uses.
# We consider both how to adapt the mathematical formalism of hybrid automata to action games and how game designers might benefit from a declarative language for describing action game behaviors.
* Hierarchical state machines and hybrid automata
# Transition systems and hybrid automata have both led to successful analysis approaches in a variety of software domains, and we believe they can be applied to action games as well.
State transition systems show up frequently in computer science and software engineering.
Their explicit representation of a bounded set of discrete states and allowed transformations from one state to the next are an appealing constraint both on open-ended imperative languages (where we see ~enum~ types or the object-oriented State Pattern) and on strongly-typed functional languages (as in the use of fancy types to enforce a function call sequence).
Notably, even when an explicit state machine construct is not provided, user code and APIs often have the essential characteristics of state machines: for example, a struct may contain flags denoting its current mode of operation, or it may be illegal to call one function after another has been called.

Game designers often narrate their characters' behaviors in terms of state machines, and this trend is captured in the academic literature in e.g. cite:siu2016Bosses (our work may be seen as a rigorous grounding of the same fundamental idea).
This state machine-like description addresses characters' physical dynamics, audiovisual representation, and discrete variables like health or ammunition.
These are not formal transition systems: they may have undecidable transition relations (due to various combinations of dynamics and transition guards) or their discrete state spaces may be infeasibly large.
Some of these variations can be captured by other types of automata, but in general games have so far used state machine-flavored discrete systems rather than formal automata.

** Hybrid automata (networks)
Hybrid automata combine a discrete transition system (a finite state machine) with a set of continuous variables and a switched set of differential equations over these variables called /flows/ cite:alur1993hybrid.
In each state, a different subset of the flows is applied to the continuous variables until the state is exited along a transition, which may refer to continuous variables rather than to symbols from an input string; transitions may also instantaneously modify variables' values.
The usual semantics for hybrid automata is that they alternate between periods of continuous flow (called /delay/ or /continuous transitions/) and instantaneous /discrete transitions/.

Hybrid automata have seen extensive use in modeling cyber-physical systems where linear (or simpler) dynamics adequately describe the partially known or complex true dynamics of a system whose behavior is different at different times.
They have many varieties and syntactic extensions, and often their dynamics are restricted in one way or another: see cite:henzinger2000theory for a survey.
Dynamics restrictions are helpful because even under very simple physical laws, the question of state reachability becomes intractable or even undecidable.

Some key analysis questions here include /safety/ or system state reachability; calculating a /reachable region/ (what possible values can the continuous variables take?); /controller synthesis/ (can we generate a control policy which will be safe or meet some optimality criterion?); and /parameter synthesis/ (given an automaton with some unknown parameters, can we find values for those parameters satisfying some constraint?).
A further question, given the complexity of answering the above with either discrete-time simulation (as in /Simulink/) or geometric techniques (as in /PHAVer/ cite:frehse2005phaver): can we handle larger problems by analyzing an automatically derived abstraction of the original automaton and applying the results back to the original?

Game characters often have highly structured behaviors: for example, Super Mario's grounded movement comprises walking, running, and standing still, while his aerial movement has distinct rising and falling behaviors composed in parallel with moving left and right in midair.
Modeling these distinct flows requires dozens of discrete states, most of which are slight variations on each other.
Hundreds of characters may be created and destroyed at runtime; this alone could put a significant stress on existing hybrid automata tools.
# There are also semantic concerns: action game physics are rarely linear.
# Worse still, many transitions are forced by complex invariants involving the character's relationship to terrain and other characters, so this simplistic model of Mario's movement is extremely non-convex.

# ** Hierarchical hybrid automata
Recently, /modularity/ has become a focus of hybrid systems research in two senses: first, given two automata with certain properties (e.g. safety), can they be composed so that those properties still hold; and second, can we define models with less structural repetition?
Another concern is reconfigurability---adding or removing automata from the system at runtime.
Notable projects in this area are CHARON cite:alur2001compositional and its reconfigurable extension R-CHARON cite:kratz2006r.

In action games, the first sense of modularity is contingent on the characters involved: many game characters depend strongly on the behaviors of e.g. the player, so extreme modularity may not be realistic.
The CHARON family also only supports parallel composition of behaviors near the top of the hierarchy, and this restriction is inconvenient for modeling game characters with complex but highly structured behaviors.
Still, it should be useful to adapt ideas and semantics from CHARON for games.

# Games also need domain-specific theories for collision between objects of various types, because we have foreknowledge about the game's simulated spatial environment and many questions of interest to game designers require or assume information about the environment.
# Moreover, by treating collision detection as first-class we can translate directly to efficient implementations in modern game engines.
# But do game designers care about the hybrid automata analysis questions listed above?
# If not, are there other questions which are more appropriate?
* Why model action games?
Source code is the final specification of a video game, and the intricate rules of a game seem to necessitate an imperative, low-level semantics.
So, why model action games at all?
Several projects have successfully argued that games' emergent qualities---to wit, the unpredictability of players---leave a substantial role for model checking in game design practice.
The educational puzzle game /Refraction/ used model checking to ensure that all solutions to a puzzle required the use of necessary mathematical concepts cite:smith2013quantifying.
Some continuous-time games incorporate solution-finding into their game design itself: /CloudberryKingdom/ generates new game levels on the fly but ensures that they can be won by a player with bounded reaction time cite:cloudberryKingdom.
Besides finding solutions, two other automated methods are gaining in popularity among action game designers: visualizing (approximations of) reachable regions cite:bauer2012rrt,isaksen2015exploring,shaker2013ropossum; and visualizing the results of a fixed input sequence as game levels and/or code are changed (popularized by cite:victor2012inventing, Inform 7's /Skein/ debugger cite:reed2010creating, and /Super Mario Maker/).
Our aim is to improve the availability of these sorts of tools (which reduce the need for expensive manual testing) without being too tied to specific games or game-making tools.
# Simpler techniques are even more widely used, for example playing random sequences of inputs and ensuring that the game does not crash.

Game programs have certain characteristics that distinguish them from the typical use-case of source code model checkers.
First, game code is characterized by a single tight "main loop" which runs 30 or 60 times per second; model checkers must deal with very many program points for accurate results.
Efficient collision detection also requires complex heap data structures tracking the membership of objects in various spatial partitions.
Moreover, important properties like level geometry, the characters within a level, and controller mappings are frequently only determined at runtime.
Even worse, rendering code is rarely split from game logic, and the line between the game and its user interface is often (justifiably) blurry.
Higher level modeling languages could ameliorate many of these problems, but they will not be adopted if they are not both convenient to use and easy to translate to low-level game programs.
The Micromachinations system for modeling game /economies/ (exchanges of discrete quantities) satisfies that constraint by treating the high-level model as a kind of library with respect to the game program proper cite:van2014adapting, and it is an inspiration for the present work.

Some game-making tools do support partial declarative definitions of game character behaviors.
Most notably, GameMaker provides for entities with behaviors driven by events (such as collisions or timer elapse) that trigger handlers supporting various conditional responses (e.g. changing velocity or incrementing a variable).
These entities also have varying animations at different times and collision areas which correspond to the animations.
Unfortunately, game characters with atomic behaviors outside of that predefined set are inexpressible in the declarative style; the GML scripting language is provided as an imperative escape hatch for such cases.
The 3D game-making tools Unreal and Unity both provide for explicit state machines specialized for character animation, but in both engines most atomic behaviors are implemented in imperative code.
None of these tools has a formal semantics.

In the academy, the Video Game Description Language (VGDL) cite:schaul2013video uses action games as a testbed for general game-playing and general intelligence.
VGDL offers a few fixed types of game character archetypes and physics models, sufficient to address a fairly large space of games.
It also provides for entities to react in various pre-defined ways to collision events with other entities or level geometry.
Unfortunately, VGDL therefore shares with the tools above the issues of limited expressiveness (without the escape hatch of arbitrary code) and a semantics which can only be defined with respect to its implementation.
# For these and other reasons, VGDL is not ideal for our present purpose.

# Finally, when considering HyPED, we were drawn to the use of ADSR (attack/decay/sustain/release) envelopes to describe game character dynamics over single variables, which as far as we know originated in cite:gameFeel.
# These envelopes can be seen as small hybrid automata whose transitions are guarded on velocity thresholds or user input changes, and they seem to be useful for describing the movement of game characters.

While on the surface hybrid automata seem to be a natural fit for modeling action games, previous attempts to apply them to this purpose have been stopped short by limitations of the modeling languages and model checkers cite:aaron2002hybrid.
Our own earlier (unpublished) attempts at modeling action games via hybrid automata fell short in two similar ways.
First, our formalism was low-level: individual states defined either constant velocities or constant accelerations (up to fixed velocity limits) for variables.
This was sufficient to express a broad class of games, but it was extremely verbose: many states were small variations on each other, combined in predictable and structured ways---but this structure was hidden from the model checker.

Secondly, this low-level formalism only permitted low-level analysis.
It was hard to reuse analysis of e.g. /rightward/ horizontal movement for the /leftwards/ case; even the difference between walking and running rightwards led to many symmetries that our naive model checker could not break.
These two problems were both due to working at the wrong level of abstraction: the level of hybrid automata rather than the level of action game design.
** Graphical Logics :noexport:
*** OLs and definitions of the relevant ones
*** Evident connection to hybrid automata networks
**** Discrete states plus physics

* HyPED
The main design goal of HyPED is to translate concepts from hybrid control theory to the theory of action games so that tools and techniques from the former can be applied in the latter.
There are substantial differences between classical hybrid automata and game character state machines, some of which have been detailed above.
Here, we present a high-level account of how we identified and accounted for those differences.
More complete documentation, including syntax and a source code repository, can be found at [[http://url]].

#+NAME:1-flappy
#+begin_src plantuml :file 1-flappy.png :cache yes
skinparam monochrome true
state Flappy {
  Flappy: Parameters: flap_speed = 40, move_speed = 10          Collider: rect(0,0,16,16) body         Flows: gravity = 10
  [*] -right-> Alive
  state Alive {
    Alive: Flows: x' = move_speed
    [*] -right-> Falling
    Flapping: Flows: y' = flap_speed
    Flapping -left-> Falling : !flap off
    Falling -right-> Flapping : !flap on
  }
  Alive -right-> Dead : touching(body,wall)
  Dead: Flows: x' = 0, y' = 0
}
#+end_src

#+CAPTION:    Flappy Bird
#+NAME:      fig:1-flappy
#+ATTR_LaTeX: :width 0.75\linewidth
#+RESULTS[18b3b2c63904f32494d4d3b222d53c280ba852c6]: 1-flappy
[[file:1-flappy.png]]

** Structure and semantics
Our immediate goal was to eliminate repetitive definitions by incorporating hierarchy and parallel composition of behavioral modes.
Fig. [[fig:1-flappy]] illustrates hierarchical modeling with a simple /Flappy Bird/-like character.
=Flappy= is parameterized on flapping speed and move speed, and as a global flow it assigns a value to gravitational acceleration (defining implicitly the flow =y'' = -gravity=).
It also bounds the character's terminal velocity.
Bounds can be derived implicitly, but declarations like this could admit easier analysis or act as safety properties.
It has one collider: a square positioned at the character's real position, tagged =body=.
Note that the =Alive= parent state has a transition to =Dead=; this transition is available in both =Falling= and =Flapping=, and if it is available it must be taken.
=Flows= and =Bounds= defined in ancestor states also apply in descendants, unless explicitly overridden (as in the =Dead= state's =y' = 0=, which overrides the implicit effects of gravity).
The flows of a character with multiple active parallel modes are the union of those flows; conflicting assignments to a single variable are illegal.
Thanks to this restriction, we can /flatten/ HyPED characters into simple hybrid automata using product and sum constructions, but we suspect it would be better to perform analysis on the hierarchical model instead.
# This automaton has three atomic states, whose fully qualified names correspond to their place in the hierarchy: =Alive.Falling=, =Alive.Flapping=, and =Dead=.
# This formulation of Flappy only elides a few explicit transitions and flow declarations, but for complex characters the savings become substantial.

# HyPED uses so-called /urgent/ transitions which must be taken when available; nondeterministic user-input transitions are the exception.
# We follow cite:minopoli for a reduction to the conventional formalism (via mode invariants) if necessary.

As in some hybrid automata formalisms (e.g. cite:koutsoukos2000supervisory), HyPED makes use of explicitly defined input signals.
Inputs are either button or axis inputs, and are given an optional group and a required name (e.g. =p1/jump= or =p2/x=).
This representation of inputs permits the use of either nondeterministic transitions or a controller/plant decomposition, as it gives clear affordances for external control.
# Button inputs have four states: pressed, on, off, and released, where pressed and released are effectively zero-crossings of the signal.
# Axis inputs range between -1 and 1.

We also allow discrete variables (not uncommon in hybrid automata schemes) as a convenience for games with resources such as character health or ammunition.
Finite-domain variables could also represent a character's current spatial heading (for example, a 2-tuple which must be one of =(-1,0)=, =(1,0)=, =(0,-1)=, or =(0,1)=).
# These could naively be reduced to simple hybrid automata via parameterized states, where every mode is implicitly instantiated once per possible value of every discrete variable.
# Of course, more efficient reductions and analyses are possible!

From R-CHARON, we adopt reference variables as a special type of discrete variables, along with the creation and destruction of characters at run-time.
As in R-CHARON, if a mode uses properties of a reference variable in any way, the variable must have a non-null value on entry.
Moreover, such modes /must/ also define a transition on the =unlinked(ref)= event, of which one is provided for each reference variable.
We also provide a notation for searching for objects satisfying certain criteria, either by some criterion (e.g. minimum distance) or nondeterministically.
# (possibly by reduction to using a fixed pool of characters of each type, a common trick used by game programmers).
# These are important in games to model behaviors such as projectiles targeting specific characters (as opposed to specific positions), or to create enemies with multiple body segments that follow each other in sequence.
# It is an error if no such transition is available in the event the reference becomes null.

# Early versions of HyPED explicitly represented collision between objects using guards that checked character bounding boxes.
# This was tedious and error-prone, so we introduced a syntactic sugar based on /collision logics/ cite:collisionLogics.
# While more concise than before, models still needed to define collision /handling/, e.g. the cessation of movement when an object encountered a wall.
# This was a burden, and moreover the second-class status of collision logics prevented efficient collision detection.
HyPED characters carry a set of tagged /colliders/ of various primitive shapes and guards may implicitly quantify over those collider tags.
Metadata in the HyPED definition describe which tags block the movements of which other tags along which normal vectors, and whether this occlusion should also reset the corresponding velocity components to zero.
We also admit arbitrary guards to determine which colliders are active at which times.
# These semantics could either be reduced to explicit guards or treated as a black box from the perspective of a controller/plant decomposition.

When modeled in the intuitive way described here, action game characters have highly non-convex state invariants.
This is largely because it is useful to model the world as part of the system dynamics.
As an example, Mario may be =Walking= either to the left or to the right of a wall, even if walking through walls is impossible---perhaps a =Jumping= mode helped the character reach the new position.
Unlike the common robot scenario for hybrid systems, we have perfect knowledge of the game world so we have the option of making some of these non-convexities explicit if it helps analysis.
# To reduce to convex hybrid automata, we could perform invariant synthesis to find all the convex regions comprising each mode's invariant; this explodes the state space, so research on directly analyzing these complex modes is ongoing.

A key philosophical difference with hybrid automata is that the modeled game physics are by definition the true dynamics of the system.
This means we have the flexibility to trade precision for simpler dynamics in a disciplined way if the precise dynamics are difficult to analyze.
# Most game programs give continuous physics a piecewise linear interpretation with a discrete time step, so there is no theoretical difficulty here on the games side.

A final semantic adaptation is the /envelope/, which encapsulates a small hybrid automaton with a graphical description.
Popularized by cite:swink2009game, an envelope describes the behavior of a single continuous variable (generally a velocity) over time as user input or other events take place (see Fig. [[fig:2-mario]] for an example that also covers joint transitions via =enter= and creating objects).
Envelopes have four phases: /attack/, where the variable accelerates to a given value over a given duration (or at a given rate); /decay/, where the variable decreases to the /sustain/ level over a given duration (or, again, at a given rate); /sustain/, where the variable keeps its value steady until an event; and /release/, where the variable is either released from envelope control or is reduced to a given value over a given duration (or at a given rate) before being released.
An envelope may also define an invariant which, if violated, immediately triggers a /release/ event.

# If a variable's value is already nonzero at the start of the envelope, the /attack/ phase is shortened so that the variable only has to increase from its current value to the target value.
# Likewise, if the variable is less than zero, the attack phase takes longer than usual.
# A /release/ may happen at any time, not just during the /sustain/ phase.
# Of course, any continuous (ideally monotonic) function could be used instead of the constant rates implied above.

# At definition time, envelopes are parameterized in a variety of ways.
Envelopes are defined to operate on particular continuous variables.
They may be mirrored (=2-way=), in which case positive and negative versions of the envelope are defined.
They may also be mirrored in four or more directions (=4-way=, =8-way=, etc), taking two variables (treated as =x= and =y=) and treating the controlled quantity as a magnitude.
Each distinct instantiation of the envelope (one for each direction) provides the direction.
# If the envelope is =free=, the two variables are treated as =magnitude= and =direction=.
# Envelopes can be reduced to hybrid automata by creating one state per phase and setting up appropriate transitions, but as-is they might provide useful structure for analysis.

#+NAME:2-mario
#+begin_src plantuml :file 2-mario.png :cache yes
skinparam monochrome true
state Mario {
  Mario: (Flows, parameters, ...)
  ' [*] -right-> Alive
  ' Dead: Flows: x' = 0, y' = 0
  ' Alive -down-> Dead : Size.Small & enter Hurt.Yes
  ' state Alive {
    state Size {
      [*] -right-> Small
      Small -right-> Big : touching(body, mushroom)
      Small --> Fire : touching(body, flower)      
      Big -right-> Fire : touching(body, flower)
      Big -left-> Small : enter Hurt.Yes
      Fire -left-> Big : enter Hurt.Yes
      Fire --> Fire : !p1/fire pressed, create MarioFire()
    }
    ||
    state Hurt {
      [*] -right-> No
      No -right-> Yes : touching(body,enemy) & not (touching(body,bottom,enemy) & y' < 0)
      Yes -left-> No : timer(1.0)
    }
    --
    state Movement {
      [*] --> Ground
      state Ground {
        [*] -right> Walking
        Walking -right> Running : !p1/run on
        state Walking {
          Walking: envelope 2-way x':!p1/x\n  A acc 16\n  S walk_speed\n  R acc brake_acc
        }
        state Running {
          Running: envelope 2-way x':!p1/x\n  A acc 32\n  S walk_speed*2\n  R acc brake_acc
        }
        Running -left> Walking : !p1/run off
      }
      Ground -> Falling : not touching(body,bottom,wall)
      Ground -> Jumping : !p1/jump pressed
      state Jumping {
        Jumping: On enter: jump_timer := 0, y' := 144
        Jumping: Flows: gravity = fall_gravity / 2, jump_timer' = 1
        Jumping: envelope 2-way x':!p1/x\n  A acc 8.0\n  S run_speed\n  R keep
      }
      Jumping -> Falling : timer(0.8), y' := min(y', 100)
      Jumping -> Falling : touching(body,top,wall)
      state Falling {
        Falling: envelope 2-way x':!p1/x\n  A acc 8.0\n  S run_speed\n  R keep
      }
      Falling -> Walking : touching(body,bottom,wall) & !p1/run off
      Falling -> Running : touching(body,bottom,wall) & !p1/run on
    }
  '}
}
#+end_src

#+CAPTION:    Mario (abbreviated)
#+NAME:      fig:2-mario
#+RESULTS[ca078ff7f72591ee3fed2f106c257c3d6d8f7354]: 2-mario
[[file:2-mario.png]]

** Execution and Analysis
Games also have distinctive analysis objectives.
Properties like safety (interpreted with respect to e.g. a designer's desired game outcomes) are not as important in practice as having a wide range of exploratory visualizations and explanatory tools to understand and evaluate the consequences of design decisions.

Reachability is still useful and can be queried using conventional techniques: bounded model checking or symbolic execution of either the continuous-time model or a discrete-time approximation, or even Monte Carlo methods.
Precise invariant synthesis could also serve a helpful role.
Even relatively simple checks like proving every defined mode can be reached in play could ease the work of the game designer, for example as part of automated regression testing.
In the preceding section we have pointed out some opportunities for automated abstraction; other options may be to perform analysis at a specific hierarchical depth (taking the union of behaviors of child modes), of only one character at a time, with some variables treated as intervals rather than values, and so on.

Besides formal analysis, HyPED opens new avenues for visualization and debugging support tools.
The spatial nature of action games immediately suggests superposing reachable regions or witness execution traces onto the game map.
Presenting the designer with a live diagram showing which modes and which transitions have been active recently could be useful for understanding character behaviors, and paired with a rewind function could vastly improve the character debugging experience.
Parameter synthesis given some desired waypoints along a preferred path could reduce time spent tweaking values.
These are just a few possible tools made substantially easier by a declarative representation of action game characters.

HyPED games could be executed via direct interpretation (using quadratic programming to find transition times) or by synthesizing a discrete-timestep game program, potentially on top of an existing game engine (making use of its physics and collision handling code).
# The question of missing short-time-window transitions that arises in discrete approximations of hybrid automata is well-known in games as /tunneling/, where it exhibits as e.g. fast-moving objects moving into or through thin walls.
# Game programmers generally resolve these issues by trading physical correctness for efficiency and ease of implementation, and HyPED could follow suit.

** Detailed syntax---save for tciaig or something else :noexport:
*** Characters
 The top level of a HyPED schema defines a set of ~Characters~.
 A ~Character~ is introduced by a declaration like =char Mario= or =char Fireball enemy|projectile|unblockable=.
 In the latter case, an optional set of ~Tags~ is given separated by vertical bars.
 These ~Tags~ have no special semantics, but can be used to refine quantifiers.
 ~Characters~ have ~Constants~, ~Parameters~, and ~Variables~ as well as ~Modes~ and ~Colliders~.
 ~Constants~ are defined by a line like =const fall_gravity = -10=, and take their type from their assigned value.
 Integers may be implicitly upgraded to reals, but the reverse is not possible without an operation like truncation or rounding.
 ~Parameters~ are given by a line like =param start_direction = left in left|right=.
 This gives both the default value and the set of allowed values: lowercase words as values are akin to LISP /symbols/, and the vertical bar creates an anonymous union type.
 Since the initial value of a typed union is implicitly its first/leftmost syntactic member, we could have written =param start_direction in left|right=.

 ~Variables~ may be either ~Continuous~ or ~Discrete~.
 ~Continuous Variables~ are defined similarly to ~Parameters~ but with a =var= keyword: =var star_timer in 0..1=.
 ~Ranges~ like =0..1= or =50..100= include their upper and lower bounds, and their first element is their lower bound.
 Depending on context, they may be either continuous or discrete.
 ~Discrete Variables~ are defined with the =dvar= keyword: =dvar lives = 3 in 0..99=.
 Like ~Parameters~, ~Variables~ may be set at object initialization time, but ~Continuous Variables~ may be changed during continuous flows and both types of ~Variable~ may be changed during discrete transitions.
 Every ~Character~ implicitly has three spatial ~Continuous Variables~ =x=, =y=, and =z=.
 ~Constants~, ~Parameters~, and ~Variables~ share a single namespace and may not be defined more than once per ~Character~.

 Besides the properties above, objects may put ~bounds~ on the derivatives of ~cvars~, e.g. =bound y' > -200= or =bound |x'| < 32= (both =bound x' > -32= and =bound x' < 32=).
 Some analysis backends or runtimes may benefit from the use of bounds, or flag an error if user-provided bounds are exceeded.
 If all velocities are constants, and under some other conditions, bounds can be inferred automatically.

 A ~Character~ also has an implicit top-level ~Mode~ (see [[Modes]]).
 Any declaration legal in a ~Mode~ is also legal at a ~char's~ top-level.
 This is commonly used to define the acceleration due to gravity for a character, as in=gravity = -10=.

 Finally, a ~char~ defines a set of ~Colliders~ (see [[Colliders and collision]]).
*** Modes
**** States
**** Flows
***** Only continuous variables or cv' or cv'' = other continuous variables (possibly of other characters, if given as parameters--similar to hybrid I/O automata but not as strict given collision rules)
**** State nesting
***** Syntax for naming states
***** flow overrides/augmentations
**** Parallel states
**** Sugar: On-entry updates
*** Colliders and collision
**** could be either a sugar or natively handled if there's a good theory for it
*** Edges
**** Guards
***** State checks
***** Discrete variable checks
***** Continuous variable checks (of this and other characters if given as parameters or maybe if suitably quantified, see above note on flows)
***** Collision checks
***** Input controller checks
**** Continuous and discrete variable updates
**** Joint transitions
     Effectively, guards on "did this other state just now change?"
*** Creating and destroying characters
**** Pooling approach and "spawners" (similar to statically allocated objects)
**** Dynamic logic approach (similar to dynamically allocated objects)
*** Sugar: ADSR Envelopes
*** Sugar: Parameterized states

** Less detailed but still too detailed :noexport:
*** Characters                                                     :noexport:
 A HyPED schema is some metadata along with a set of named /character types/, each of which defines a set of (continuous and discrete) /constants/, /parameters/, and /variables/ along with a set of behavioral /modes/ and /colliders/.
 A character section is introduced by a declaration like =char Mario= and an increase in indentation on the subsequent line.
 The section ends when the indentation level (of a non-empty line) decreases (indentation is significant in HyPED).
 Other declarations are atomic and indentation and whitespace are not significant between their beginning and end.

 Implicitly, every character has as many positional variables as dimensions in the simulated space: =x=, =y=, and sometimes =z=.
 At runtime, /instances/ of the =char= are created with potentially customized variables for the parameters or starting values for variables.
 Parameters may not be changed after the instance is created, and discrete variables may only be changed during discrete transitions.
 Characters may also define bounds on continuous variables or their derivatives (for =x=: =bound x' < 200=, =bound x'' > -10=, and so on).

 Finally, a character may define one or more /collider sections/, which each contain a sequence of /conditional sections/, /collider declarations/, and child collider sections.
 Primitive colliders include =rect(x,y,w,h)= and other primitives such as circles, spheres, axis-aligned and oriented boxes, capsules, and so on.
 Here, =x= and =y= refer to offsets from the character's true position.
 In a future extension, these properties may be allowed to be expressions.
 Colliders may be grouped arbitrarily, groups and colliders may be given comma-separated lists of tags, and both groups and colliders can be made conditional on guards (see [[Transitions]]).
 # A colliders section begins with the keyword =colliders= and a comma-separated sequence of tags, and it increases indentation.
 # A conditional section begins with the keyword =while= and a guard (see [[Transitions]]), increases indentation, and may contain any of the above.
 # A collider declaration comprises a collider constructor and an optional comma-separated sequence of tags, e.g. =rect(0,0,16,16) body, player=.

 One vitally important piece of metadata in the HyPED schema are the sets of collision tags which occlude each other: =solid a b= for each such pair of tags =a= and =b=.
 Objects with active colliders with one such tag will halt any movement that would force those colliders to interpenetrate active colliders with the other tag.
 Colliders of the same type may interpenetrate, so =solid a a= is a reasonable statement.

 Characters also define an implicit top-level /mode/, and any declaration which would be legal in a mode is legal at the top level of a character.
*** Modes                                                          :noexport:
 A /mode/ defines a set of /flows/, /transitions/, and zero or more /child mode groups/.
 Modes correspond to the hierarchical hybrid automata states of cite:alur2001compositional.
 A mode with no children is atomic, and a mode with multiple child mode groups runs each in parallel.
 Child mode groups are introduced by =group GroupName= declarations.
 Mode and mode group names must begin with a capital letter.
 Each child mode group is defined by a set of (mutually exclusive) modes, each of which may be arbitrarily complex.
 =group= declarations increase indentation, and their subsections may only be /mode declarations/ with the name of the mode followed by a newline, an increase in indentation, and a set of declarations valid in a mode.
 Mode sections, mode declarations, and groups all end when indentation levels decrease from the level of their initial line.

 If a character has an active mode with child groups, each child group must also have an active mode, recursively.
 A character's current "mode" is therefore its set of active atomic modes, and all flows and transitions of the active atomic modes and their direct ancestors are active, unless the respective flow is overridden by a child's flows.
 It is illegal for multiple simultaneously active explicit flows in different family trees to conflict.
 Since every mode and mode group is named, it is possible to uniquely refer to any mode using =Parent.Child.Grandchild= notation; within a mode, partial names are implicitly resolved using the mode's direct ancestors and descendants only.
 Ambiguous references are illegal.

 Each mode may define a set of flows which alter the character's continuous variables.
 A flow may do one of two things.
 First, a flow may set the value of a variable or one of its derivatives to a constant or parameter (e.g. =y' = 0= to force y-velocity to 0 and ignore gravity, as opposed to =y'' = 0= which would stop the effects of gravity but keep the old y-velocity).
 Second, it may set the value of a variable or one of its derivatives to an expression involving other continuous variables or analog user inputs, potentially of other characters if an R-CHARON-like reference variable type is introduced.
 Implicitly, at the top level for each character, every continuous variable =v= evolves with the flows =v = v + v'=, =v' = v' + v''=, =v'' = 0=; =y= gains the additional flow =y'' = gravity=.

**** Transitions

 Mode transitions are introduced with declarations of the form =when guard -> TargetMode, updates=.
 The /guard/ is a Boolean combination (using =&=, =|=, and =not=) of variable threshold expressions, active mode checks, collision checks, and user input checks.
 The /target mode/ is an atomic mode name in a direct ancestor mode group of the mode defining the transition.
 In other words, the transition has to cause the current mode to become inactive and another atomic mode to become active.
 TODO: clarify?
 The /updates/ are an optional comma-separated sequence of assignments =var := expression= to variables or their derivatives.
 If any variables appear in the expression, their values just before the transition are used.

 Variable threshold expressions are inequalities over arithmetic expressions involving variables, parameters, and constants.
 Active mode checks provide an unambiguously named mode and succeed if the given mode is currently active.
 Collision checks take the form =touching(my_collider_type,my_side,their_collider_type)=; =my_side= is optional and may be =x+=, =x-=, =y+=, =y-=, and so on (for more complex colliders, a normal vector could potentially be provided instead).
 User input checks are of the form =!player/input test=, where =player= names a player of the game, =input= names a predefined input (which may be either binary or analog), and =test= is a keyword from the set =pressed=, =on=, =off=, =released= (for binary inputs) or an inequality with a numeric constant (for analog inputs).
 Mapping hardware controllers to user inputs is the responsibility of the concrete context of use.

 Finally, the transition-like declaration =when guard ! reconfigure=, where guards are as above, can be used to create and destroy characters at runtime.
 /Reconfigure/ must be a comma separated sequence with elements of the form =create CharacterType(Assignments)=, =destroy this=.
 /CharacterType/ should name a defined =char= and /Assignments/ should be a comma-separated sequence of assignments =var := expression=, similar to updates except with the ability to set parameters.
 This may be given a semantics through object pooling if the number of characters of each type is fixed in advance, or through dynamic creation and destruction of objects.

*** Envelope Syntax                                                :noexport:
 this is important. and so are examples and semantics... agh, there's so much stuff that must be elided above!!!

*** Extension: Parameterized States                                :noexport:

* Future Work
In this paper, we presented an adaptation of hybrid automata for action games.
Two example characters were provided, though HyPED is capable of expressing more varied game characters in finer detail.

While we have implemented a naive model checker using traditional hybrid automata techniques for a subset of HyPED, its performance is not acceptable for want of efficient nonlinear constraint solvers; reduction to linear constraints leads to very long traces and intractable analysis.
Hopefully, the structure provided by full HyPED will help analysis scale.

# Evaluating the language design proper as well as the visualizations and analysis workflow will require working closely with expert game designers.
# A central question here is whether hybrid automata are more pleasant to use than source code or the ad hoc state machine descriptions that game designers currently employ---or, if they are not as straightforward, we would want to know if the design support features outweigh the inconvenience.

Extending the principles behind HyPED to other types of games is also an important project.
Many types of games deal with a combination of continuous and discrete state, including strategy and simulation games.
These games do not necessarily center complex characters, so many of HyPED's features are irrelevant, but the analysis backend might be very similar.

# Finally, a language for specifying desired properties of hybrid automata or their traces would be useful.
# Playspecs adapt \omega-regular expressions to discrete games and have a straightforward timed extension cite:playspecs, but the hierarchical hybrid CTL of cite:hrctl may be more appropriate for the kinds of systems HyPED describes.
** Game level corpus integration (game behavior corpus) :noexport:
** Idle games :noexport:

* Back matter :ignore:

\bibliographystyle{splncs03}
\bibliography{padl}
