#+LATEX_CLASS: article
#+LATEX_CLASS_OPTIONS:
#+LATEX_HEADER:
#+LATEX_HEADER_EXTRA:
#+DESCRIPTION:
#+KEYWORDS:
#+SUBTITLE:
#+DATE: \today
#+OPTIONS: toc:nil
#+TITLE: Modeling action games as hierarchical hybrid automata
#+AUTHOR: Joseph C. Osborn, Michael Mateas
#+EMAIL: jcosborn@soe.ucsc.edu, michaelm@soe.ucsc.edu

* Abstract
Action video games are multi-agent systems combining discrete game-character (or agent) states with (simulated) continuous movement and collision. Many popular game-making tools---both manual and fully automated---have focused on action games as their object of interest, perhaps due to their popularity and conceptual simplicity as playable spatial simulations. These tools mostly use ad hoc formalisms or have basically imperative semantics.

Although games share common ancestry with control theory and hybrid systems, declarative notations for games have only seen limited use. We propose a modeling language that can be given semantics directly or via translation to existing game-making tools. Thus, design support tools could be written once for this portable representation while keeping open the option of game-specific implementation.

Game designers often describe their work in terms of state machines or control envelopes, so we ground our modeling language in hybrid automata, specifically hierarchical hybrid automata. We select features and syntax from the hybrid systems literature which are appropriate to the domain of games and hopefully admit tractable, compositional analysis and convenient modeling.
* Introduction
In this paper, we consider a particular loosely-defined set of video games commonly referred to as "action games" or "graphical-logic games" cite:graphicalLogicGames.
These games center simulations of continuous space and time, collisions between objects, and objects whose behaviors change under different circumstances (generally indicated by changes in visual appearance).
Sometimes, discrete variables (generally with small domains) also determine the discrete or continuous dynamics of the system.

This category of graphical-logic games is quite expressive and a large number of examples naturally fall into it.
Accordingly, many popular game-making tools focus on these sorts of games: GameMaker, Unity 3D, Unreal, Construct, and a variety of other systems offer user interfaces and programming APIs supporting collision checking, simple physics, and in some cases state machines (todo:cites).
At the same time, none of these systems offer significant support for model checking (or even automated testing), visualization of possible system states, parameter synthesis, or other features that the available domain knowledge would seem to enable.
These tools could be of great use to game makers.

In our work, we follow after the game description language /cum/ game engine /cum/ model checker BIPED (todo:cite): to take one specification and generate both human-playable games and machine-analyzable systems.
BIPED is specialized to games with discrete state spaces and a fairly coarse discrete interpretation of time; what would a BIPED-like system for continuous-time games with hundreds of real-valued variables look like?
We answer this question by combining folk approaches of action game makers---state machines, object pooling, broad-vs-narrow phase collision detection, game physics simulation, and so on---with formal approaches from the hybrid systems literature.
Our language and system are called HyPED (Hybrid BIPED).
The following sections position it in relation to existing formalisms for hybrid automata and action game specification, provide its syntax and several semantics, and point to future applications and uses.
We consider both how to adapt the mathematical formalism of hybrid automata to action games and how game designers might benefit from a declarative language for describing action game behaviors.
* Hierarchical state machines and hybrid automata
State transition systems show up frequently in computer science and software engineering.
Their explicit representation of a bounded set of discrete states and allowed transformations from one state to the next are an appealing constraint on open-ended imperative languages (where we see `enum` types or the object-oriented State Pattern) and on strongly-typed functional languages (as in the use of phantom types or linear types to enforce a function call sequence).
State machines in the guise of coroutines are also used widely in languages like Python, Javascript, C#, and Clojure.
Notably, even when an explicit state machine construct is not provided, user code and APIs often have the essential characteristics of state machines: for example, a struct may contain flags denoting its current mode of operation, or it may be illegal to call one function after another has been called.

Here, games are no exception.
Game designers often narrate their characters' behaviors in terms of state machines (todo:cite), and this trend is captured in the academic literature in e.g. cite:siu2016Bosses (in fact, the present work may be seen as a rigorous theoretical grounding of the same fundamental idea).
Notably, the state machines described above do not necessarily maintain all the invariants of true transition systems, they may have undecidable transition relations (due to various combinations of transition guards), their state spaces may be infeasibly large, and they may have various dynamics while in a particular state.
Some of these variations can be captured by other types of automata (e.g., discrete variable changes may be described by counter automata), but in general they are "state machine-flavored" discrete systems rather than formal automata.

A particularly successful variation on state machines in the software engineering world comes from UML's Statecharts (todo:cite).
These are a very expressive formalism covering concurrent, hierarchical transition systems with a variety of extensions around multiplicity, synchronization, and "default" states in each machine.
One concrete realization of Statecharts comes in Concurrent Hierarchical State Machines cite:CHSMs, a parser generator-like tool which outputs C code.
These machines have an explicit transition system structure but implicit "anything-goes" dynamics within each state and during transitions, so they provide only limited support for static analysis.
To find state machines that explicitly model what happens /while in/ a state, we turn to hybrid automata.
** Hybrid automata (networks)
Hybrid automata combine a discrete transition system (a finite state machine) with a set of continuous variables, a switched set of differential equations over these variables called called "flows" (identified with the states from the transition system) and an "event generator" which may (nondeterministically) emit transition events conditioned on the values of the continous variables TODO:cite.
In each state, a different subset of the flows is applied to the continuous variables until the state is exited along a transition; transitions may also reset continuous variables instantaneously.
The usual semantics for hybrid automata is that they alternate between periods of continuous flow (sometimes called delay transitions or continuous transitions) and instantaneous discrete transitions.

Hybrid automata have seen extensive use in modeling cyber-physical systems where linear (or simpler) dynamics adequately describe the partially known or complex true dynamics of a system whose behavior is different at different times.
Examples include train, car, and plane crash prevention TODO:cite, robot navigation TODO:cite, and factory automation TODO:cite.
They come in many varieties, generally by restricting their dynamics in one way or another: there are rectangular hybrid automata which reset their variables during every transition cite:rectHA, linear hybrid automata with linear dynamics cite:linearHA, lazy linear hybrid automata with bounded delays on transition intervals cite:lazyLinearHA, and many others.
Dynamics restrictions are necessary because even under very simple dynamics, the question of state reachability becomes intractable or even undecidable.
Multiple automata working in concert may be synchronized across designated transitions todo:cite or via designated output and input variables cite:hybridIOAutomata.
The field is far too wide to adequately address in such little space, 

Some key analysis questions in hybrid automata modeling include:
- Safety/state reachability: Could the automaton get into a bad state? If so, how?
- Reachable region: What possible values can the continuous variables take in the operation of the automaton or within a particular state?
- Control synthesis: Generate an (implementable) control policy which is guaranteed not to get the automaton into a bad state, or is guaranteed to perform optimally in some way.
- Parameter synthesis: Given a hybrid automaton with some unknown parameters (e.g. transition thresholds or flow equations), and example runs, can we find values for the unknown parameters?

A further question, given the complexity of answering these questions either with discrete-time simulation (in the style of Simulink cite:Simulink) or geometric techniques (in the style of PHAVer cite:PHAVer): can we automatically derive a simpler automaton by abstracting the original automaton, and then apply the results of analyzing the abstraction back to the original?

Game characters often have highly structured behaviors: for example, Super Mario's grounded movement comprises walking, running, and standing still, while his aerial movement has distinct rising and falling behaviors composed with moving left and right in midair.
Modeling these different flows explicitly requires dozens of discrete states, most of which are slight variations on each other.
In addition to syntactic concerns, there are semantic ones as well.
Game physics in action games are not always linear, and they almost never "rectangular"---continuous variables are reset only rarely.
Worse still, many transitions are forced by complex invariants involving the character's relationship to terrain and other characters, so the "few dozen states" model of Mario's movement described above is extremely non-convex.
Finally, games may have character counts numbering in the hundreds, which would put a significant stress on most existing hybrid automata analysis tools.
Some of these concerns, especially around modeling convenience, have been raised in the hybrid systems literature as well.

** Hierarchical hybrid automata
Recently, numerous modeling conveniences have been proposed on top of hybrid automata.
One main interest has been in modularity, in two senses: first, given two automata with certain properties (e.g. safety), can they be composed in such a way that those properties still hold; and second, can we define hybrid automata models with less structural repetition?
Another concern is reconfigurability---adding or removing automata from the system at runtime (in games, this could provide for the creation and destruction of game entities).
Some notable work in this area includes Hierarchical Hybrid Automata cite:hierarchicalHybridAutomata, CHARON cite:charon, and CHARON's reconfigurable extension R-CHARON cite:rcharon --- all of which can be seen as hybrid variations on UML Statecharts!

CHARON and R-CHARON have a very strong focus on the first sense of modularity, even extending to modular simulation---running two agents separately (within a bounded time delay) is guaranteed to be approximately the same as running the agents together.
In action games, this property is extremely contingent on the specifics of the agents involved: many game characters depend strongly on the behaviors of e.g. the player or other characters.
The CHARON family also only supports parallel composition of behaviors near the top of the hierarchy, and this restriction is inconvenient for modeling game characters with complex but highly structured behaviors.
Hierarchical Hybrid Automata (HHAs) are closer to the needs of games, but the explicit definition of state invariants (as opposed to, say, Simulink's urgent transitions) and complex state-oriented (vs transition-oriented) synchronization make it less of a good fit (we also want to distinguish between agents and primitive behaviors).

Games also need domain-specific theories for collision between objects of various types, because we have foreknowledge about the game's simulated spatial environment and many questions of interest to game designers require or assume information about the environment.
Moreover, by treating collision detection as a first-class theory we can translate directly to efficient implementations in modern game engines.
But what are the game designer's analogues to the hybrid automaton analysis questions listed above?

* Why model action games?
** Motivation
*** Game code is hard to analyze using regular model checkers because their code runs so often (30 or 60 fps)
*** Game code is also hard to write, bug prone, etc
*** So, we want to make making good-feeling action games more accessible
**** (And generalize to other kinds of game as well)
*** and we want to increase the use of formal tools to reduce the need for playtesting to catch bugs or show what's possible that the designer didn't anticipate
*** Better specification formalisms are also good for e.g.:
**** learning game rules from video
**** automatic tutorialization
**** automated or mixed-initiative game generation
**** off-the-shelf recombination
**** parameter synthesis
*** Compare vs VGDL
Action games are also of interest in the academy.
Besides Super Mario Bros.'s status as a benchmark for game AI research (todo:cites), systems such as Variations Forever (todo:cite) and Game-o-Matic (todo:cite) have attempted to generate these games.
Game-specific design support tools have also been built for Flappy Bird (todo:cite), Cut the Rope (todo:cite), and other games.
The video game description language (VGDL) (todo:cite), a recent interchange format for describing graphical-logic games, treats action games as a testbed for general game-playing, 

** (Action) games and game designers use state machines a lot
*** Siu/Butler/Zook and other sources
    especially to coordinate character behavior/animation/variables
*** Worth talking about game maker action/response things and tools for novice programmers
**** Usually have to be augmented/replaced with e.g. scripting languages
*** Unity/Unreal state machine editors
*** Swink envelopes
** Operational logics interpretation of action games
*** OLs and definitions of the relevant ones
*** Evident connection to hybrid automata networks
**** Discrete states plus physics
*** Low level HA formalism (constant or accelerating linearly to a fixed limit) was sufficient to express the games but not very pleasant and very verbose, because it was at the wrong level of abstraction.
**** especially considering control envelopes which had to be spread among many states.
While on the surface HAs seem a natural fit for modeling action games, previous attempts to apply them to this purpose have been stopped short by limitations of the modeling languages and model checkers cite:gameMovementViaHAs.
*** So here's HyPED 2
* HyPED 2 Syntax
** Desiderata
*** Differences between game character state machines and regular hybrid automata
**** Required/urgent transitions like simulink
**** Complex non-convex, non-linear invariants
***** Because whole world is modeled, including collision geometry
**** But innate piecewise linear interpretation ("spatial coherence" assumption)
**** Deterministic and known rules, instead of mysterious ineffable world
***** But ineffable world can be assumed if it helps some type of analysis
*** Different analysis and expressivity objectives too
**** Natural for modeling
**** Visualization and exploratory info at least as important as safety analysis
**** This representation also seems easier for tasks such as automated game generation, learning game rules from videos of play, or tutorial synthesis.

** Characters
** Parameters
** Continuous variables
   And types
** Discrete variables
   And types
*** could be either a sugar or natively handled if there's a good theory for it
** States and flows
*** States
*** Flows
**** Only continuous variables or cv' or cv'' = other continuous variables (possibly of other characters, if given as parameters--similar to hybrid I/O automata but not as strict given collision rules)
*** State nesting
**** Syntax for naming states
**** flow overrides/augmentations
*** Parallel states
*** Sugar: On-entry updates
** Colliders and collision
*** could be either a sugar or natively handled if there's a good theory for it
** Edges
*** Guards
**** State checks
**** Discrete variable checks
**** Continuous variable checks (of this and other characters if given as parameters or maybe if suitably quantified, see above note on flows)
**** Collision checks
**** Input controller checks
*** Continuous and discrete variable updates
*** Joint transitions
    Effectively, guards on "did this other state just now change?"
** Creating and destroying characters
*** Pooling approach and "spawners" (similar to statically allocated objects)
*** Dynamic logic approach (similar to dynamically allocated objects)
** Sugar: ADSR Envelopes
** Sugar: Parameterized states
* Examples
** Flappy
** Mario
** Zelda
** Metroid
** Shmups
* Semantics
** Code generation (discrete time step)
** Code generation (discrete time step, existing physics/game engine)
*** Interesting because the discrete part is more like a controller while the physics engine acts like a plant
** Interpretation ("event driven physics")
** Reduction to other HA or transition system formalisms
** Model checking
*** Transition-time symbolic execution
*** Bounded model checking
**** Difficult on the real system, but amenable to abstraction
** Abstraction
   Many of these work by using information supplied in the sugar: e.g. control envelopes, nesting hierarchy, discrete variable or parameterized state sugar
*** Discretization of space/time
*** controller/plant
*** horizontal, i.e. across characters
*** vertical, i.e. between state groups at different levels
*** Invariant synthesis and invariant-based analysis
* Evaluation (can be small?)
* Next steps
** Visual modeling
*** See HieroMate as well
** Game level corpus integration (game behavior corpus)
** Idle games
** Actually do some of these analyses
** Do some evaluation with other game designers
** Languages for other types of games
** Playspecs
*** Also consider HRCTL (hierarchical hybrid ctl)
