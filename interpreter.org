#+TITLE: HyPED 2 "Flat" Interpreter
#+AUTHOR: Joseph C. Osborn
#+EMAIL: jcosborn@ucsc.edu
#+INFOJS_OPT:
#+PROPERTY: header-args:python :session :results silent :exports both :tangle yes

This is a fairly short file so we'll write it in linear order.

* The imports
#+BEGIN_SRC python
import xmlparser as xml
import schema as h
from collections import namedtuple
import matplotlib
matplotlib.use('Agg')
import matplotlib.pyplot as plt
import bitvector as bv
#+END_SRC
* The interpreter
** Objective
Given an automaton defined by the ~schema~ module, we have a few options: for example, we could transform it into some more efficiently executable formalism, we could interpret it directly, or we could translate it to C.  The object-oriented interpreter seems like a natural step, but the graph structure induces a fair number of challenges around maintaining certain runtime invariants, and things would quickly get tedious in Python (Visitors everywhere).  It's a little too much ceremony.  So for this interpreter, I'd like to take advantage of the structure of the problem and explore an approach that might be able to take advantage of numpy or be translated to C.

The key insight is that we know all the modes of an automaton in advance of trying to execute it, so we can use information about that fixed structure to optimize our representation both for simplicity and speed.  The specific move we make is to number each mode and group in a depth-first order, which lets us easily go between mode definitions and numerically indexed arrays.  Automata usually have fairly few distinct modes, and numbering them all lets us easily scan through them without chasing pointers everywhere.

** Definitions

Let an automaton be as in ~schema.py~, a tree of groups and modes along with a set of global default flows, a set of continuous variables and a set of discrete variables (not yet implemented), and a set of parameters which are fixed once the automaton is initialized.  A group is a collection of modes and a mode is a collection of groups along with a set of flows and edges.  A mode defines a set of flows and a set of transitions (or /edges/).  Flows choose a continuous variable, the degree to control it by (i.e. its position, velocity, or acceleration), and a constant value to force that effect.  Flows in child states on the same variable override those of parent states which override those of the automaton root; note that this means an acceleration flow in a child could override a velocity flow in the parent or vice versa.

We can load up an automaton from some XML like so:

#+NAME: load_automaton
#+BEGIN_SRC python :tangle no :results value replace
raw_automaton = xml.parse_automaton("resources/flappy.char.xml")
#+END_SRC

A valuation is a set of assignments to parameters and variables (which we will optimize later), along with an active set.  The obvious implementation of the active set would be as a set or a dict mapping qualified mode names to runtime data, or perhaps a tree of active groups and modes.  This requires lots of pointer chasing and reorganizing data structures, which is unnecessary given that the number of modes and groups in an automaton is small, fixed, and known a priori.  So we use an array for the active set whose indices can be known in advance.  The next section describes how we approach this problem.

** Constraints
Without loss of generality, let us restrict our attention to automata with only top-level parallelism, i.e. every non-root mode has at most one group.  This simplifies the transition semantics since we can say that an edge may only point to a mode which is a child of the same root group.  To further simplify the interpreter, it will be useful to define a total order over all the groups and modes of an automaton; let's say that the order is the preorder traversal order, so all parent modes are visited before their child modes.  We'll introduce new types for the interpreter (while leaving the automaton definition alone) to track a mode's ordering and its number of descendants (to aid in efficiently implementing transitions) along with some useful pre-calculated mode sets.  We will also replace the ~qualified_target~ and ~mode~ properties of edges and certain guards respectively to use these indices instead of qualified names.

#+BEGIN_SRC python
OrderedAutomaton = namedtuple("OrderedAutomaton", h.Automaton._fields+("ordering", "ordered_modes"))

OrderedMode = namedtuple("OrderedMode", h.Mode._fields+("index","descendant_count","ancestor_set","descendant_set","self_set"))

OrderedEdge = namedtuple("OrderedEdge", h.Edge._fields+("target_index",))
#+END_SRC

In our semantics, transitions of a parent mode are taken at a higher priority than transitions of a child mode, so this ordering lets us enforce that by taking a linear scan of an array of active modes.  We also want to be sure that joint transitions are always to a mode of a different group and that this joint transition relation has no cycles.  This is more cautious than we strictly need to be but it simplifies the code.  We define a ~translate_automaton~ function to convert a "stock" automaton into one that has the required ordering (or throw an error if this is not possible).

#+BEGIN_SRC python
def translate_automaton(aut):
    group_deps, ordered_list = safe_ordered_mode_list(aut.groups)
    ordering = {qn:num for num,qn in enumerate(ordered_list)}
    translated_modes = []
    for modename in ordered_list:
        m = modename.mode_in(aut.groups)
        tmode = translate_mode(m, ordering)
        translated_modes.append(tmode)
    props = aut._asdict()
    props["ordering"] = ordering
    props["ordered_modes"] = translated_modes  
    return OrderedAutomaton(**props)
#+END_SRC

First, we want to order the modes properly.  We begin by finding the group dependencies and then pick a group ordering that satisfies them, if that's possible.  Finally, we build a flat mode list in the safe order and return the group dependencies and mode ordering.  ~schema.flat_modes~ accepts any dict of groups as an argument, so we pass just one group at a time to build the ideal mode order.

#+BEGIN_SRC python
def safe_ordered_mode_list(groups):
    group_deps = group_dependencies(groups)
    ordered_groups = order_groups(groups, group_deps)
    ordered_list = []
    for g in ordered_groups:
        ordered_list.extend(h.flat_modes({g:groups[g]}))
    return (group_deps, ordered_list)
#+END_SRC

Group dependencies are found by iterating through all the descendant modes of every root group and determining the dependencies of guards of edges of modes of that group (phew).  The relation is one-to-many and binary, so we store it as a dictionary from group IDs to sets of group IDs.

#+BEGIN_SRC python
def group_dependencies(groups):
    group_deps = {}
    flat_list = h.flat_modes(groups)
    for modename in flat_list:
        gid = modename.groups[0]
        if not (gid in group_deps):
            group_deps[gid] = set()
        m = modename.mode_in(groups)
        for e in m.edges:
            assert isinstance(e, h.Edge)
            deps = guard_dependencies(e.guard)
            for dep in deps:
                group_deps[gid].add(dep)
    return group_deps
#+END_SRC

Once we have a group dependency relation, we can find an ordering.  We start by putting all the root groups in their default order into a queue (implemented as an array).  Until that queue is empty (or until we've made too many trips through the queue without solving the constraints), we pop its first element and see if its dependencies are satisfied by the groups currently in the safe ordering; of course a group with no dependencies is trivially satisfied.  If the dependencies are not met, we throw it back into the queue; otherwise, we append it to the safe ordering.

#+BEGIN_SRC python
def order_groups(groups, group_deps):
    ordered_groups = []
    group_ids = groups.keys()
    tries = 0
    max_tries = len(group_ids)**2
    while len(group_ids) > 0 and tries < max_tries:
        gid = group_ids.pop(0)
        all_met = True
        for dep in group_deps[gid]:
            this_found = False
            for present_dep in ordered_groups:
                if present_dep == dep:
                    this_found = True
            if not this_found:
                all_met = False
                break
        if all_met:
            ordered_groups.append(gid)
        else:
            group_ids.append(gid)
        tries += 1
    if len(group_ids) > 0:
        raise ValueError("No safe group order", groups, group_deps)
    return ordered_groups
#+END_SRC

Finally, we define algorithms for finding the dependencies of a guard or finding a path through that dependency relation.

#+BEGIN_SRC python
def guard_dependencies(guard):
    # Only care about root group IDs given the constraints above
    if isinstance(guard, GuardConjunction):
        ret = set()
        for g in guard.conjuncts:
            ret._replace(guard_dependencies(g))
        return ret
    elif isinstance(guard, GuardJointTransition):
        return set([guard.mode.groups[0]])
    return set()

def dep_path(a, b, deps, stack=set()):
    # find simple cycles only
    if a in stack: return False
    # find self-cycles
    if a == b: return True
    # find one-step cycles
    if b in deps[a]: return True
    # recurse for each dep, adding a to stack to avoid non-simple cycles.
    for mid in deps[a]:
        if dep_path(mid, b, deps, stack | a):
            return True
    # otherwise: no cycle!
    return False
#+END_SRC

Recall that once we have the safe mode ordering, we can translate the modes of the automaton (and the guards of their edges) and store their indices and other useful information according to that ordering.  Guard translation is just replacing mode references with mode indices.  Mode traslation also includes translating edges and caching some useful sets.

#+BEGIN_SRC python
def translate_guard(g, ordering):
    if isinstance(g, GuardConjunction):
        return g._replace(
            conjuncts=[translate_guard(gc, ordering) for gc in g])
    elif isinstance(g, GuardJointTransition):
        return g._replace(mode=ordering[g.mode])
    elif isinstance(g, GuardInMode):
        return g.replace(mode=ordering[g.mode])
    return g


def translate_mode(m, ordering):
    modenum = ordering[m.qualified_name]
    if len(m.groups) > 1:
        return "Too many groups in a non-root mode for now!"
    new_edges = []
    descendant_count = len(h.flat_modes(m.groups, m.qualified_name))
    for e in m.edges:
        eprops = e._asdict()
        eprops["target_index"] = ordering[e.qualified_target]
        eprops["guard"] = translate_guard(e.guard, ordering)
        new_edges.append(OrderedEdge(**eprops))
    props = m._asdict()
    props["index"] = modenum
    props["edges"] = new_edges
    props["descendant_count"] = descendant_count
    props["ancestor_set"] = qname_to_ancestors(m.qualified_name, ordering, include_self=False)
    props["descendant_set"] = mode_set(start=modenum, count=descendant_count, order=ordering)
    props["self_set"] = mode_set(start=modenum, count=1, order=ordering)
    return OrderedMode(**props)
#+END_SRC

At this point, we ought to give a definition of a "mode set" in this indexed regime.  We'll define mode sets as bitvectors, and provide a convenience instructor given an ordering dict.  We also provide a quick way to get all the ancestors of a qualified mode name.

#+BEGIN_SRC python
def mode_set(start=None, count=1, order=None):
    bvec = bv.BitVector(len(order))
    # Not sure this is the most efficient way!
    if not (start is None):
        for v in range(start,start+count):
            bvec[v] = 1
    return bvec

def qname_to_ancestors(qname, ordering, include_self=False):
    ms = mode_set(order=ordering)
    if not include_self:
        qname = qname.parent_mode
    while qname != None:
        ms[ordering[qname]] = 1
        qname = qname.parent_mode
    return ms
#+END_SRC

To wrap things up, let's look at usage.  To translate the automaton we loaded earlier, we can write:

#+NAME: translate_automaton
#+BEGIN_SRC python :tangle no :results value replace
automaton = translate_automaton(raw_automaton)
{v:str(k) for k, v in automaton.ordering.items()}.values()
#+END_SRC

#+RESULTS: translate_automaton
| flappy.alive | flappy.alive.movement.falling | flappy.alive.movement.flapping | flappy.dead |

** Valuations

Recall that a valuation is an active mode set, an assignment to parameters, and an assignment to variables.  This was elided before, but we may also need to track theory-specific data (where theories are things like user input, collisions, et cetera).  Let's formalize that definition:

#+BEGIN_SRC python
class Valuation(object):
    __slots__ = ["automaton", 
                 "parameters", "variables", 
                 "active_modes", "theories", 
                 "entered", "exited"]

    def __init__(self, aut, parameters, variables, active_modes):
        self.automaton = aut
        self.parameters = parameters
        self.variables = variables
        self.active_modes = active_modes
        self.theories = Theories()
        self.entered = active_modes.deep_copy()
        self.exited = mode_set(order=aut.ordering)

class Theories(object):
    __slots__ = ["input", "collision"]
    def __init__(self):
        self.input = Input()
        self.collision = Collision()
#+END_SRC

We need a way to construct a valuation from an automaton and some assignments.  Note that we handwave ~initial_modes~ for now; we'll discuss it in detail when speaking about discrete transitions and entering/exiting modes.

#+BEGIN_SRC python
def make_valuation(aut, params={}, vars={}):
    assert isinstance(aut, OrderedAutomaton)
    params = {pn: p.value.value for pn, p in aut.parameters.items()}
    vars = {vn: v.init.value for vn, v in aut.variables.items()}
    params.update(params)
    vars.update(vars)
    initial_modes = initial_mask(val)
    return Valuation(aut, params, vars, initial_modes)
#+END_SRC

Calling ~make_valuation~ is relatively straightforward, especially when using default initializers:

#+NAME: make_valuation
#+BEGIN_SRC python :tangle no :results value replace
valuation = make_valuation(automaton)
#+END_SRC

The main operations we want to perform on valuations are to effect continuous flows, discrete jumps, and theory updates.  For simplicity, this interpreter will use a fixed timestep and update the input theory, the discrete state, the continuous state, and the collision theory, in that order.

#+BEGIN_SRC python
DT = 1.0/60.0

def step(val, input_data, dt):
    val.theories.input.update(val, input_data, dt)
    discrete_step(val)
    continuous_step(val, dt)
    val.theories.collision.update(val, dt)
#+END_SRC

*** TODO may need to change some stuff when multiple HAs are allowed

** Interpreting an automaton
*** Discrete Step

The discrete step is tricky!  It has two main jobs: determining whether any edges of active modes can be taken, and then actually performing those transitions.  These are separated because each edge evaluation needs to be done with the same valuation data, and we may have parallel composition of modes.

#+BEGIN_SRC python
def discrete_step(val):
    exit_set, enter_set, updates = determine_available_transitions(val)
    # Perform the transitions and updates.  This is where the bitmask representation pays off!
    val.active_modes &= ~exit_set
    val.active_modes |= enter_set
    # Apply all the updates at once.
    for uk, uv in updates.items():
        val.variables[uk] = uv
#+END_SRC

To find available transitions, we iterate through every mode in the safe ordering.  If that mode has an edge with a satisfied guard, we take that edge and skip the rest of the mode's edges and its descendants.  The edge's update dictionary is merged with the net update dictionary (these updates may include functions of variables, so we have to evaluate them explicitly).  Any possible conflicts between updates should have been handled at automaton creation time, as would any invalid edges (e.g., transitions from a parent to its own child).

#+BEGIN_SRC python
def determine_available_transitions(val):
    exit_set = mode_set(order=val.automaton.ordering)
    enter_set = mode_set(order=val.automaton.ordering)
    # Clear the exited and enter sets of the valuation.
    val.exited = exit_set
    val.entered = enter_set
    updates = {}
    mi = 0
    modes = val.ordered_modes
    mode_count = len(modes)
    while mi <= mode_count:
        if not active[mi]: continue
        mode = modes[mi]
        for e in mode.edges:
            if eval_guard(e.guard, val):
                exit_set, enter_set = update_transition_sets(
                    val,
                    mode, modes[e.target_index],
                    enter_set, exit_set)
                # Each time we get a new mask, update the valuation's exited
                # and entered modes.
                # We need to do this since some guards depend on it.
                val.exited = exit_set
                val.entered = enter_set
                # skip descendants
                mi += mode.descendant_count
                # figure out and merge in updates
                for euk, euv in e.updates.items():
                    updates[euk] = eval_value(euv, val)
                # skip any other transitions of this mode
                break
        mi += 1
    return (exit_set, enter_set, updates)
#+END_SRC

Updating ~enter_set~ and ~exit_set~ is a bit subtle, since 1.) we may be going from a mode to one of its ancestors or their siblings, and 2.) when entering a mode we also need to enter the appropriate sub-mode (recursively).  Adding to ~exit_set~ is relatively easy, since we can mask in all of the source mode's ancestors and descendants and mask out any of those which are common ancestors with the destination mode.  ~enter_set~ requires a loop to do properly; as it turns out, we need this same sort of loop when initializing a valuation's active set, so we can explore that here as well.

#+BEGIN_SRC python
def update_transition_sets(val, src, dest, enters, exits):
    all_srcs = src.descendant_set | src.ancestor_set | src.self_set
    exits |= all_srcs & ~dest.ancestor_set
    enters |= dest.ancestor_set | dest.self_set
    enters |= initial_mask(val, dest)
    return (exits, enters)


def initial_mask(val, mode=None):
    modes = val.automaton.ordered_modes
    # Handle the root case (seen in Valuation initialization)
    mask = None
    if mode is None:
        mask = mode_set(order=val.automaton.ordering)
        mi = 0
        mlim = len(mask)
    else:
        # Handle the case where we're only looking for descendants of a particular mode
        mask = mode.ancestor_mask | mode.self_mask
        mi = mode.index
        mlim = mi + mode.descendant_count
    # TODO: Use entry edges to determine which mode to start in. 
    # May involve enters/exits being passed into this function!
    while mi <= mlim:
        this_descendant = modes[mi]
        # If this is the mode we want, use it and proceed to check its children
        if this_descendant.is_initial:
            mask[mi] = 1
        else:
            # Otherwise, skip its children and move on.
            mi += this_descendant.descendant_count
        mi += 1
    return mask
#+END_SRC

Guards are a restricted class of predicate which, ideally, we would compile using sympy or some other method.  For now, we'll interpret them.  Recall that ~mode~ properties of guards have been replaced by canonical indices at this point.

#+BEGIN_SRC python
def eval_guard(val, guard):
    if isinstance(guard, h.GuardConjunction):
        result = True
        for c in guard.conjuncts:
            # TODO: If evaluation needs a context (e.g. bindings), pass result as well
            result = result & eval_guard(val, c)
            if not result:
                return False
        return result
    elif isinstance(guard, h.GuardTrue):
        return True
    elif isinstance(guard, h.GuardInMode):
        assert guard.character is None
        return val.active_modes[guard.mode] != 0
    elif isinstance(guard, h.GuardJointTransition):
        assert guard.character is None
        if guard.direction == "enter":
            return val.entered[guard.mode]
        elif guard.direction == "exit":
            return val.exited[guard.mode]
        else:
            raise ValueError("Unrecognized direction", guard)
    elif isinstance(guard, h.GuardColliding):
        return 0 < len(val.theories.collision.get_contacts(
            guard.self_type,
            guard.normal_check,
            guard.other_type))
    elif isinstance(guard, h.GuardButton):
        if guard.status == "pressed":
            return val.theories.input.is_pressed(guard.playerID, guard.buttonID)
        elif guard.status == "on":
            return val.theories.input.is_on(guard.playerID, guard.buttonID)
        elif guard.status == "off":
            return val.theories.input.is_off(guard.playerID, guard.buttonID)
        elif guard.status == "released":
            return val.theories.input.is_released(guard.playerID, guard.buttonID)
        else:
            raise ValueError("Unrecognized status", guard)
    else:
        raise ValueError("Unrecognized guard", guard)
#+END_SRC

Expressions, like guards, ought to be compiled.  For now we accept only a very limited set and interpret them.

#+BEGIN_SRC python
def eval_value(expr, val):
    if isinstance(expr, h.ConstantExpr):
        return val.value
    elif isinstance(expr, h.Parameter):
        return eval_expr(expr.value, val)
    else:
        raise ValueError("Unhandled expr", expr)
#+END_SRC

*** Continuous Step

The continuous step applies accelerations and velocities to update continuous variables.  The complexity comes in properly stacking and giving precedence to the various currently active modes.  We can assume that no two potentially simultaneously active modes of different groups conflict on flows, and we can assert that flows of children supersede flows of parents.  These two rules suffice to prevent all conflicts and admit a relatively simple definition of continuous steps, though one that could probably be improved by incorporating something like numpy and finding a nice matrix multiplication encoding.

**** TODO Explain this better once it's rewritten (and once variable storage is rewritten too).  This should be doable without any allocations at all.

#+BEGIN_SRC python
def continuous_step(val, dt):
    flows = {}
    # TODO: Ordering variables would give us a way around using dicts here.
    # We could store [v1, v1', v1'', v2, v2', v2'', ...]
    # Let's revisit it once we have a better representation for variable storage.
    for f in val.automaton.flows.values():
        fvar = f.var
        fvalexpr = f.value
        fval = eval_expr(fvalexpr, val)
        flows[fvar.name] = (fvar, fval)
    modes = val.automaton.ordered_modes
    active = val.active_modes
    mi = 0
    mlim = len(modes)
    while mi < mlim:
        if not active[mi]:
            mi += modes[mi].descendant_count
        else:
            for f in modes[mi].flows.values():
                fvar = f.var
                fvalexpr = f.value
                fval = eval_expr(fvalexpr, val)
                flows[fvar.name] = (fvar, fval)
        mi += 1
    vbls = val.automaton.variables
    pos_vbls = [v for v in vbls.values() if v.degree == 0]
    for pos in pos_vbls:
        (_, vel, acc) = h.all_derivs(pos, vbls)
        val_pos = val.variables[pos.primed_name]
        val_vel = val.variables[vel.primed_name]
        val_acc = val.variables[acc.primed_name]
        # see if it's in the flow dict.
        if pos.name in flows:
            # If so, update its vel or acc according to the flow, set any
            # higher degrees to 0, and update lower degrees as above
            # (acc->vel, vel->pos).
            (fvar, fval) = flows[pos.name]
            if fvar.degree == 2:
                val_acc = fval
                val_vel = val_vel + val_acc * dt
                val_pos = val_pos + val_vel * dt
            elif fvar.degree == 1:
                val_acc = 0
                val_vel = fval
                val_pos = val_pos + val_vel * dt
            else:
                val_acc = 0
                val_vel = 0
                val_pos = fval
        else:
            # If not, update its vel according to its acc and its pos
            # according to its vel.
            # Note that implicit or "uncontrolled" flows like this have
            # different semantics from default flows like "y'' = gravity"!
            # val_acc = val_acc
            val_vel = val_vel + val_acc * dt
            val_pos = val_pos + val_vel * dt
        val.variables[pos.primed_name] = val_pos
        val.variables[vel.primed_name] = val_vel
        val.variables[acc.primed_name] = val_acc
        
#+END_SRC

*** Input Theory

For now we're just looking at a digital binary input theory, where individual buttons can be on or off and spend one frame in the pressed and released states respectively when transitioning from one to the other.

#+BEGIN_SRC python
class Input(object):
    __slots__ = ["pressed", "on", "released"]

    def __init__(self):
        self.pressed = set()
        self.on = set()
        self.off = set()
        self.released = set()

    def update(self, inputs, dt):
        # update on, off, pressed, released accordingly
        buttons = set(inputs)
        # clear pressed and released
        self.pressed.clear()
        self.released.clear()
        # move ON to RELEASED if not in buttons
        for b in self.on:
            if not (b in buttons):
                self.released.add(b)
        for b in self.released:
            self.on.remove(b)
        # put new buttons into PRESSED and ON
        for b in buttons:
            self.pressed.add(b)
            self.on.add(b)

    # TODO: Handle players

    def is_pressed(self, player, button):
        return button in self.pressed

    def is_on(self, player, button):
        return button in self.on

    def is_off(self, player, button):
        return not self.is_pressed(player, button)

    def is_released(self, player, button):
        return button in self.released
#+END_SRC

*** TODO Collision Theory

#+BEGIN_SRC python
class Collision(object):
    __slots__ = ["contacts"]

    def __init__(self):
        self.contacts = []

    def update(self, val, dt):
        pass

    def get_contacts(self, self_type, normal_check, other_type):
        return []
#+END_SRC

* The test case

#+BEGIN_SRC python :noweb yes :tangle no :results value replace
<<load_automaton>>
<<translate_automaton>>
<<make_valuation>>
#+END_SRC

#+RESULTS:

#+BEGIN_SRC python :results file replace :tangle no
dt = 1.0/60.0
history = []
for step in [(60, []), (60, ["flap"]), (60, [])]:
    for i in range(step[0]):
        step(valuation, step[1], dt)
        history.append(valuation.variables["y"])
# collect positions and graph
plt.plot(history)
plt.gca().invert_yaxis()
plt.savefig('ys')
print history
return 'ys.png'
#+END_SRC

# Local Variables:
# org-src-preserve-indentation: (quote t)
# End:
