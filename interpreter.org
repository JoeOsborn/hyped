#+TITLE: HyPED 2 "Flat" Interpreter
#+AUTHOR: Joseph C. Osborn
#+EMAIL: jcosborn@ucsc.edu
#+INFOJS_OPT:
#+PROPERTY: header-args:python :session :results silent :exports both :tangle yes

This is a fairly short file so we'll write it in linear order.

* The imports
#+BEGIN_SRC python
import xmlparser as xml
import schema as h
from collections import namedtuple
import matplotlib
matplotlib.use('Agg')
import matplotlib.pyplot as plt
import bitvector as bv
#+END_SRC


* The interpreter
** Objective
Given an automaton defined by the ~schema~ module, we have a few options: for example, we could transform it into some more efficiently executable formalism, we could interpret it directly, or we could translate it to C.  The object-oriented interpreter seems like a natural step, but the graph structure induces a fair number of challenges around maintaining certain runtime invariants, and things would quickly get tedious in Python (Visitors everywhere).  It's a little too much ceremony.  So for this interpreter, I'd like to take advantage of the structure of the problem and explore an approach that might be able to take advantage of numpy or be translated to C.

The key insight is that we know all the modes of an automaton in advance of trying to execute it, so we can use information about that fixed structure to optimize our representation both for simplicity and speed.  The specific move we make is to number each mode and group in a depth-first order, which lets us easily go between mode definitions and numerically indexed arrays.  Automata usually have fairly few distinct modes, and numbering them all lets us easily scan through them without chasing pointers everywhere.

** Definitions

Let an automaton be as in ~schema.py~, a tree of groups and modes along with a set of global default flows, a set of continuous variables and a set of discrete variables (not yet implemented), and a set of parameters which are fixed once the automaton is initialized.  A group is a collection of modes and a mode is a collection of groups along with a set of flows and edges.  A mode defines a set of flows and a set of transitions (or /edges/).  Flows choose a continuous variable, the degree to control it by (i.e. its position, velocity, or acceleration), and a constant value to force that effect.  Flows in child states on the same variable override those of parent states which override those of the automaton root; note that this means an acceleration flow in a child could override a velocity flow in the parent or vice versa.

We can load up an automaton from some XML like so:

#+NAME: load_automaton
#+BEGIN_SRC python :tangle no
raw_automaton = xml.parse_automaton("resources/flappy.char.xml")
#+END_SRC

A valuation is a set of assignments to parameters and variables (which we will optimize later), along with an active set.  The obvious implementation of the active set would be as a set or a dict mapping qualified mode names to runtime data, or perhaps a tree of active groups and modes.  This requires lots of pointer chasing and reorganizing data structures, which is unnecessary given that the number of modes and groups in an automaton is small, fixed, and known a priori.  So we use an array for the active set whose indices can be known in advance.  The next section describes how we approach this problem.

** Constraints
Without loss of generality, let us restrict our attention to automata with only top-level parallelism, i.e. every non-root mode has at most one group.  This simplifies the transition semantics since we can say that an edge may only point to a mode which is a child of the same root group.  To further simplify the interpreter, it will be useful to define a total order over all the groups and modes of an automaton; let's say that the order is the preorder traversal order, so all parent modes are visited before their child modes.  We'll introduce new types for the interpreter (while leaving the automaton definition alone) to track a mode's ordering and its number of descendants (to aid in efficiently implementing transitions) along with some useful pre-calculated mode sets.  We will also replace the ~qualified_target~ and ~mode~ properties of edges and certain guards respectively to use these indices instead of qualified names.

#+BEGIN_SRC python
OrderedAutomaton = namedtuple("OrderedAutomaton", h.Automaton._fields+("ordering", "ordered_modes"))

OrderedMode = namedtuple("OrderedMode", h.Mode._fields+("index","descendant_count","ancestor_set","descendant_set","self_set"))

OrderedEdge = namedtuple("OrderedEdge", h.Edge._fields+("target_index",))
#+END_SRC

In our semantics, transitions of a parent mode are taken at a higher priority than transitions of a child mode, so this ordering lets us enforce that by taking a linear scan of an array of active modes.  We also want to be sure that joint transitions are always to a mode of a different group and that this joint transition relation has no cycles.  This is more cautious than we strictly need to be but it simplifies the code.  We define a ~translate_automaton~ function to convert a "stock" automaton into one that has the required ordering (or throw an error if this is not possible).

#+BEGIN_SRC python
def translate_automaton(aut):
    group_deps, ordered_list = safe_ordered_mode_list(aut.groups)
    ordering = {qn:num for num,qn in enumerate(ordered_list)}
    translated_modes = []
    for modename in ordered_list:
        m = modename.mode_in(aut.groups)
        tmode = translate_mode(m, ordering)
        translated_modes.append(tmode)
    props = aut._asdict()
    props["ordering"] = ordering
    props["ordered_modes"] = translated_modes  
    return OrderedAutomaton(**props)
#+END_SRC

First, we want to order the modes properly.  We begin by finding the group dependencies and then pick a group ordering that satisfies them, if that's possible.  Finally, we build a flat mode list in the safe order and return the group dependencies and mode ordering.  ~schema.flat_modes~ accepts any dict of groups as an argument, so we pass just one group at a time to build the ideal mode order.

#+BEGIN_SRC python
def safe_ordered_mode_list(groups):
    group_deps = group_dependencies(groups)
    ordered_groups = order_groups(groups, group_deps)
    ordered_list = []
    for g in ordered_groups:
        ordered_list.extend(h.flat_modes({g:groups[g]}))
    return (group_deps, ordered_list)
#+END_SRC

Group dependencies are found by iterating through all the descendant modes of every root group and determining the dependencies of guards of edges of modes of that group (phew).  The relation is one-to-many and binary, so we store it as a dictionary from group IDs to sets of group IDs.

#+BEGIN_SRC python
def group_dependencies(groups):
    group_deps = {}
    flat_list = h.flat_modes(groups)
    for modename in flat_list:
        gid = modename.groups[0]
        if not (gid in group_deps):
            group_deps[gid] = set()
        m = modename.mode_in(groups)
        for e in m.edges:
            assert isinstance(e, h.Edge)
            deps = guard_dependencies(e.guard)
            for dep in deps:
                group_deps[gid].add(dep)
    return group_deps
#+END_SRC

Once we have a group dependency relation, we can find an ordering.  We start by putting all the root groups in their default order into a queue (implemented as an array).  Until that queue is empty (or until we've made too many trips through the queue without solving the constraints), we pop its first element and see if its dependencies are satisfied by the groups currently in the safe ordering; of course a group with no dependencies is trivially satisfied.  If the dependencies are not met, we throw it back into the queue; otherwise, we append it to the safe ordering.

#+BEGIN_SRC python
def order_groups(groups, group_deps):
    ordered_groups = []
    group_ids = groups.keys()
    tries = 0
    max_tries = len(group_ids)**2
    while len(group_ids) > 0 and tries < max_tries:
        gid = group_ids.pop(0)
        all_met = True
        for dep in group_deps[gid]:
            this_found = False
            for present_dep in ordered_groups:
                if present_dep == dep:
                    this_found = True
            if not this_found:
                all_met = False
                break
        if all_met:
            ordered_groups.append(gid)
        else:
            group_ids.append(gid)
        tries += 1
    if len(group_ids) > 0:
        raise ValueError("No safe group order", groups, group_deps)
    return ordered_groups
#+END_SRC

Finally, we define algorithms for finding the dependencies of a guard or finding a path through that dependency relation.

#+BEGIN_SRC python
def guard_dependencies(guard):
    # Only care about root group IDs given the constraints above
    if isinstance(guard, GuardConjunction):
        ret = set()
        for g in guard.conjuncts:
            ret._replace(guard_dependencies(g))
        return ret
    elif isinstance(guard, GuardJointTransition):
        return set([guard.mode.groups[0]])
    return set()

def dep_path(a, b, deps, stack=set()):
    # find simple cycles only
    if a in stack: return False
    # find self-cycles
    if a == b: return True
    # find one-step cycles
    if b in deps[a]: return True
    # recurse for each dep, adding a to stack to avoid non-simple cycles.
    for mid in deps[a]:
        if dep_path(mid, b, deps, stack | a):
            return True
    # otherwise: no cycle!
    return False
#+END_SRC

Recall that once we have the safe mode ordering, we can translate the modes of the automaton (and the guards of their edges) and store their indices and other useful information according to that ordering.  Guard translation is just replacing mode references with mode indices.  Mode traslation also includes translating edges and caching some useful sets.

#+BEGIN_SRC python
def translate_guard(g, ordering):
    if isinstance(g, GuardConjunction):
        return g._replace(
            conjuncts=[translate_guard(gc, ordering) for gc in g])
    elif isinstance(g, GuardJointTransition):
        return g._replace(mode=ordering[g.mode])
    elif isinstance(g, GuardInMode):
        return g.replace(mode=ordering[g.mode])
    return g


def translate_mode(m, ordering):
    modenum = ordering[m.qualified_name]
    if len(m.groups) > 1:
        return "Too many groups in a non-root mode for now!"
    new_edges = []
    descendant_count = len(h.flat_modes(m.groups, m.qualified_name))
    for e in m.edges:
        eprops = e._asdict()
        eprops["target_index"] = ordering[e.qualified_target]
        eprops["guard"] = translate_guard(e.guard, ordering)
        new_edges.append(OrderedEdge(**eprops))
    props = m._asdict()
    props["index"] = modenum
    props["edges"] = new_edges
    props["descendant_count"] = descendant_count
    props["ancestor_set"] = qname_to_ancestors(m.qualified_name, ordering, include_self=False)
    props["descendant_set"] = mode_set(start=modenum, count=descendant_count, order=ordering)
    props["self_set"] = mode_set(start=modenum, count=1, order=ordering)
    return OrderedMode(**props)
#+END_SRC

At this point, we ought to give a definition of a "mode set" in this indexed regime.  We'll define mode sets as bitvectors, and provide a convenience instructor given an ordering dict.  We also provide a quick way to get all the ancestors of a qualified mode name.

#+BEGIN_SRC python
def mode_set(start=0, count=1, order=None):
    bvec = bv.BitVector(len(order))
    # Not sure this is the most efficient way!
    for v in range(start,start+count):
        bvec[v] = 1
    return bvec

def qname_to_ancestors(qname, ordering, include_self=False):
    ms = mode_set(order=ordering)
    if not include_self:
        qname = qname.parent_mode
    while qname != None:
        ms[ordering[qname]] = 1
        qname = qname.parent_mode
    return ms
#+END_SRC

To wrap things up, let's look at usage.  To translate the automaton we loaded earlier, we can write:

#+NAME: translate_automaton
#+BEGIN_SRC python :tangle no :results value replace
automaton = translate_automaton(raw_automaton)
{v:str(k) for k, v in automaton.ordering.items()}.values()
#+END_SRC

#+RESULTS: translate_automaton
| flappy.alive | flappy.alive.movement.falling | flappy.alive.movement.flapping | flappy.dead |

** Valuations

Recall that a valuation is an active mode set, an assignment to parameters, and an assignment to variables.  This was elided before, but we may also need to track theory-specific data (where theories are things like user input, collisions, et cetera).  Let's formalize that definition:

#+BEGIN_SRC python
class Valuation(object):
    __slots__ = ["automaton", "parameters", "variables", "active_modes", "theories"]
    def __init__(self, aut, parameters, variables, active_modes):
        self.automaton = aut
        self.parameters = parameters
        self.variables = variables
        self.active_modes = active_modes
        self.theories = Theories()

class Theories(object):
    __slots__ = ["input", "collision"]
    def __init__(self):
        self.input = Input()
        self.collision = Collision()
#+END_SRC

We need a way to construct a valuation from an automaton and some assignments:

#+BEGIN_SRC python
def make_valuation(aut, params={}, vars={}):
    assert isinstance(aut, OrderedAutomaton)
    params = {pn: p.value.value for pn, p in aut.parameters.items()}
    vars = {vn: v.init.value for vn, v in aut.variables.items()}
    params.update(params)
    vars.update(vars)
    initial_modes = mode_set(order=aut.ordering)
    for mode in aut.ordered_modes:
        # TODO: determine which modes to start in based on group guards.
        if mode.is_initial:
            initial_modes[mode.index] = 1
    return Valuation(aut, params, vars, initial_modes)
#+END_SRC

The main operations we want to perform on valuations are to effect continuous flows, discrete jumps, and theory updates.  For simplicity, this interpreter will use a fixed timestep and update the input theory, the discrete state, the continuous state, and the collision theory, in that order.

#+BEGIN_SRC python
DT = 1.0/60.0

def step(val, input_data, dt):
    val.theories.input.update(val, input_data, dt)
    discrete_step(val)
    continuous_step(val, dt)
    val.theories.collision.update(val, dt)
#+END_SRC

*** Discrete Step

*** Continuous Step

*** Input Theory

For now we're just looking at a digital binary input theory, where individual buttons can be on or off and spend one frame in the pressed and released states respectively when transitioning from one to the other.

#+BEGIN_SRC python
class Input(object):
    __slots__ = ["pressed", "on", "released"]

    def __init__(self):
        self.pressed = set()
        self.on = set()
        self.off = set()
        self.released = set()

    def update(self, inputs, dt):
        # update on, off, pressed, released accordingly
        buttons = set(inputs)
        # clear pressed and released
        self.pressed.clear()
        self.released.clear()
        # move ON to RELEASED if not in buttons
        for b in self.on:
            if not (b in buttons):
                self.released.add(b)
        for b in self.released:
            self.on.remove(b)
        # put new buttons into PRESSED and ON
        for b in buttons:
            self.pressed.add(b)
            self.on.add(b)
#+END_SRC

*** Collision Theory

#+BEGIN_SRC python
class Collision(object):
    __slots__ = ["contacts"]

    def __init__(self):
        self.contacts = []

    def update(self, val, dt):
        pass
#+END_SRC

* The test case

#+BEGIN_SRC python :noweb yes
<<load_automaton>>
<<translate_automaton>>
<<make_valuation>>
#+END_SRC

#+BEGIN_SRC python :results file
dt = 1.0/60.0
history = []
for step in [(60, []), (60, ["flap"]), (60, [])]:
    for i in range(step[0]):
        input_theory_update(automaton,
                            valuation,
                            theories,
                            dt,
                            step[1])
        discrete_step(automaton, valuation, theories)
        continuous_step(automaton, valuation, theories, dt)
        collision_theory_update(automaton,
                                valuation,
                                theories,
                                dt)
        history.append(valuation.variables["y"])
# collect positions and graph
plt.plot(history)
plt.gca().invert_yaxis()
plt.savefig('ys')
print history
return 'ys.png'
#+END_SRC

# Local Variables:
# org-src-preserve-indentation: (quote t)
# End:
